
\documentclass[a4paper,12pt]{article}

\usepackage{listings}
\usepackage{../lab}

\begin{document}

\labtitle{4}{1}

\labtheme{Обобщенное программирование. Стандартная библиотека шаблонов
  (STL).}

\labgoal{Получить навыки обобщенного программирования с использованием
  шаблонов.}

\tableofcontents

\section{Задание}
\label{sec:Task}

В этой лабораторной работе студенту необходимо реализовать шаблон
STL-контейнера в соответствие с выбранным вариантом. Реализованный
шаблон контейнера должен соответствовать следующим требованиям:

\begin{itemize}
\item иметь как минимум один шаблонный аргумент, который задает тип
  элементов, для хранения которых будет использоваться специализация
  контейнера
\item предлагать \lstinline|typedef|’ы \lstinline|value_type|,
  \lstinline|reference|, \lstinline|const_reference|,
  \lstinline|pointer| и др. (полный перечень определяется вариантом
  задания и разработчиком)
\item конструктор по умолчанию (создает пустой контейнер)
\item конструктор копирования
\item деструктор
\item проверка на пустой контейнер (метод \lstinline|empty|)
\item очистка контейнера (метод \lstinline|clear|)
\item перегруженный оператор присваивания \lstinline|=|
\item перегруженные операторы сравнения: \lstinline|==|,
  \lstinline|!=|, \lstinline|>|, \lstinline|<|, \lstinline|>=|,
  \lstinline|<=|
\item методы для доступа к элементам контейнера (перечень зависит от
  варианта задания)
\item методы для добавления элементов в контейнер (перечень зависит от
  варианта задания)
\item методы для удаления элементов из контейнера (перечень зависит от
  варианта задания)
\item предлагать классы итераторов для перебора элементов и методы для
  их создания (тип итераторов и перечень методов зависит от варианта
  задания)
\item перегруженный оператор вывода \lstinline|<<|, который использует
  итераторы контейнера и обобщенный алгоритм \lstinline|std::for_each|
  для вывода элементов в поток
\item при возникновении ошибочной ситуации должно выбрасываться
  исключение
\end{itemize}

Механизм тестирования на усмотрение разработчика: меню или юнит-тесты.

При защите лабораторной работы студент должен уметь использовать
шаблоны С++, обладать знаниями о структуре STL, свойствах
STL-контейнеров, типах STL-итераторов, использовании STL-алгоритмов и
функторов.

Для получения теоритических сведений студенту необходимо изучить главу
14 <<Шаблоны>>, главу 20 <<Структуры данных>>, главу 22 <<Библиотека
стандартных шаблонов>> из книги Х. Дейтела и П. Дейтела <<Как
программировать на С++>> 2008 года издания.  Для получения более
обширной практической информации об использовании шаблонов и STL будет
изучение семинаров 3 и 6 из книги Павловская Т. А., Щупак
Ю. А. <<C++. Объектно-ориентированное программирование: Практикум>>.

Дополнительная информация:

\begin{itemize}
\item
  \href{http://www.solarix.ru/for_developers/cpp/stl/stl.shtml#IDAPMBEJ}{Более
    подробно про итераторы и STL (на русском языке)}
\item \href{http://www.sgi.com/tech/stl/index.html}{Документация по
    SGI STL}
\item
  \href{http://www.cyberguru.ru/programming/cpp/cpp-traits.html}{Что
    такое классы свойств (traits)?}
\end{itemize}

\textbf{Усложнение}

В качестве второго аргумента шаблона контейнера добавить класс свойств
типа элемента контейнера.

\section{Варианты заданий}
\label{sec:Variants}

\subsection{Неориентированный граф (Матрица смежности)}
\label{sec:Variant_undir_graph_adj_matrix}

При выборе этого варианта необходимо реализовать шаблонный класс
контейнера для представления неориентированного графа с использованием
матрицы смежности. Класс не должен раскрывать способ представления
графа, а должен предлагать typedef’ы методы и итераторы для работы. У
шаблона должен быть один аргумент, который определяет тип, значения
которого будут храниться в вершине графа.

Реализованный шаблон класс представления неориентированного графа
должен соответствовать следующим требованиям (общие требования см. в
общей части задания):

\begin{itemize}
\item проверка присутствия вершины в графе
\item проверка присутствия ребра между вершинами в графе
\item получение количества вершин
\item получение количества ребер
\item вычисление степени вершины
\item вычисление степени ребра
\item добавление вершины
\item добавление ребра
\item удаление вершины
\item удаление ребра
\item двунаправленный итератор для перебора вершин
\item двунаправленный итератор для перебора ребер (совет: обратите
  внимание на класс \lstinline|std::pair|)
\item двунаправленный итератор для перебора ребер, инцидентных вершине
\item двунаправленный итератор для перебора вершин, смежных вершине
\item удаление вершины по итератору на вершину
\item удаление ребра по итератору на ребро
\item обратные (reverse) модификации для всех итераторов
\item константные модификации для всех итераторов
\end{itemize}

Необходимость создания шаблонных классов-оберток для представления
вершин и ребер на усмотрение разработчика.

Дополнительная литература:
\begin{itemize}
\item
  \href{http://khpi-iip.mipk.kharkiv.edu/library/datastr/book_sod/kgsu/oglav4.html}{Способы
    представления графов}
\end{itemize}

\newcommand{\graphvar}[1]{%
\subsection{#1}

Основные требования смотреть в
\ref{sec:Variant_undir_graph_adj_matrix}. }

\graphvar{Ориентированный граф (Матрица смежности)}
\graphvar{Неориентированный граф (Матрица инцидентности)}
\graphvar{Ориентированный граф (Матрица инцидентности)}
\graphvar{Неориентированный граф (Список смежности)}
\graphvar{Ориентированный граф (Список смежности)}
\graphvar{Неориентированный граф (Упорядоченные списки ребер)}
\graphvar{Ориентированный граф (Упорядоченные списки ребер)}
\graphvar{Неориентированный граф (Ортогональный список смежности)}
\graphvar{Ориентированный граф (Ортогональный список смежности)}
\graphvar{Неориентированный граф (Структура Вирта)}

Для перебора смежных вершин реализовать последовательный (однонаправленный) итератор.

\graphvar{Ориентированный граф (Структура Вирта)}
Требования смотреть в 1-ом варианте и 11-ом вариантах.

\graphvar{Неориентированный граф (Модифицированная структура Вирта)}
\graphvar{Ориентированный граф (Модифицированная структура Вирта)}

\end{document}
