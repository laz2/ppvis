
\documentclass[a4paper,12pt]{article}

\usepackage[cm]{fullpage}

% Включаем русский язык
\usepackage{latexsym}
\usepackage[warn]{mathtext}     % русские буквы буквы в формулах (с предупреждением)
\usepackage[english,russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{indentfirst}        % русский стиль: отступ первого абзаца раздела

% Подключаем графику
\usepackage[pdftex]{graphicx}
\pdfcompresslevel=9
\graphicspath{{images/}}

% Подключаем математические формулы
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{cmap}               % Поиск по русским буквам в pdf

\usepackage{hyperref}

\usepackage[usenames]{color}

\usepackage{cite}

\usepackage{listings,fancyvrb}
\lstset{language=C++,
  basicstyle=\small\ttfamily,
  commentstyle=\color[rgb]{0,0.5,0},
  keywordstyle=\color[rgb]{0,0,1},
  stringstyle=\color[rgb]{0.7,0.1,0.1},
  columns=fullflexible,
  frame=single,
  escapechar=\%,
  extendedchars=\false,
  mathescape=\true
}

\renewcommand{\ref}[1]{\hyperef[#1]{\ref*{#1}}}

\begin{document}

\section{Варианты заданий}
\label{sec:Tasks}

\subsection{Вектор}

Описать класс для работы с вектором, который задается координатами
концов в трехмерном пространстве.  Класс должен реализовывать
следующие возможности:

\begin{itemize}
\item получение координат концов вектора;
\item вычисление длины вектора;
\item сложение двух векторов (операторы \lstinline|+|,
  \lstinline|+=|);
\item вычитание двух векторов (операторы \lstinline|-|,
  \lstinline|-=|);
\item произведение двух векторов (операторы \lstinline|*|,
  \lstinline|*=|);
\item произведение вектора на число (операторы \lstinline|*|,
  \lstinline|*=|);
\item деление двух векторов (оператор \lstinline|/|, \lstinline|/=|);
\item определение косинуса между двумя векторами (оператор
  \lstinline|^|);
\item операторы для сравнения двух векторов (операторы \lstinline|>|,
  \lstinline|>=|, \lstinline|<|, \lstinline|<=|);
\end{itemize}

\subsection{Англо-русский словарь}

Описать класс, реализующий англо-русский словарь в виде бинарного
дерева (в узлах хранится пара слов, причем английское слово является
ключом). Класс должен реализовывать следующие возможности:

\begin{itemize}
\item добавление нового английского слова и перевода для него
  (оператор \lstinline|+=| для работы как со строками в стиле С -
  \lstinline|char *|, так и в стиле С++ - \lstinline|std::string|);
\item удаление существующего английского слова из словаря (оператор
  \lstinline|-=|);
\item поиск перевода английского слова (оператор \lstinline|[]|);
\item замена перевода английского слова (оператор \lstinline|[]|);
\item определение количества слов в словаре;
\item возможность загрузки словаря из файла;
\end{itemize}

\subsection{Прямоугольник}

Описать класс прямоугольника со сторонами, параллельными осям
координат. Вершины прямоугольников имеют должны иметь целочисленные
координаты. Класс должен реализовывать следующие возможности:

\begin{itemize}
\item получение координат вершин;
\item перемещение;
\item изменение размера;
\item увелечение размера на единицу по каждой из осей (оператор пре- и
  постинкремента \lstinline|++|);
\item уменьшение размера на единицу по каждой из осей (оператор пре- и
  постдекремента \lstinline|--|);
\item построение наименьшего прямоугольника, содержащего два заданных
  прямоугольника (оператор \lstinline|+|);
\item построение наименьшего прямоугольника, содержащего два заданных
  прямоугольника, с присваиванием (оператор \lstinline|+=|);
\item построение прямоугольника, являющегося общей частью
  (пересечением) двух прямоугольников (оператор \lstinline|-|);
\item построение прямоугольника, являющегося общей частью
  (пересечением) двух прямоугольников, с присванием (оператор
  \lstinline|-=|);
\end{itemize}

\subsection{Теория множеств}

Описать класс "Множество".
Класс должен реализовывать следующие возможности:

\begin{itemize}
\item элементом множества может быть другое множество;
\item проверка на пустое множество;
\item добавление элемента;
\item удаление элемента;
\item определение мощности множества;
\item проверка принадлежности элемента множеству (\lstinline|operator[]|);
\item объединение двух множеств (\lstinline|operator+| и \lstinline|operator+=|);
\item пересечение двух множеств (\lstinline|operator*| и \lstinline|operator*=|);
\item разность двух множеств (\lstinline|operator-| и \lstinline|operator-=|);
\item построение булеана данного множества;
\end{itemize}

\subsubsection{Множество}

Описать класс "Неориентированное канторовское множество".  Класс
должен реализовывать следующие возможности:

формирование множества из строки, как из char *, так и из std::string (пример: {a, b, c, {a, b}, {}, {a, {c}}}). 

\subsubsection{Мультимножество}

Описать класс "Неориентированное мультимножество".
Класс должен реализовывать следующие возможности:

формирование множества из строки, как из char *, так и из std::string (пример: {a, a, c, {a, b, b}, {}, {a, {c, c}}}). 


\subsection{Игры}

\subsubsection{Крестики-нолики}

Описать класс, реализующую игру "Крестики-нолики" (поле произвольного размера) между двумя игроками.
Класс должен реализовывать следующие возможности:

проверки возможности установки крестика/нолика в указанной позиции;
получение значения указанной позиции (оператор []);
установка значения указанной позиции (оператор []);
проверка победы одного из игроков; 

Программа, которая использует описанный класс, должна иметь консольный интерфейс с меню для игры в "Крестики-нолики".

\subsubsection{Пятнашки}

Описать класс, реализующий игру-головоломку "Пятнашки". Начальное
размещение номеров — случайное. Реализовать методы для осуществления
перестановки клеток, для проверки правильной расстановки клеток.
Класс должен реализовывать следующие возможности:

cлучайное начальное размещение номеров;
перестановка клеток;
получения значения клетки (оператор []);
проверка правильной расстановки клеток. 

Программа, которая использует описанный класс, должна иметь консольный интерфейс с меню для игры в "Пятнашки".

\subsubsection{Кубик Рубика}

Описать класс, реализующий игру-головоломку "Кубик Рубика".  Класс
должен реализовывать следующие возможности:

случайное начальное размещение цветов;
загрузка начального размещения цветов из файла;
поворот грани кубика;
проверка правильной расстановки цветных клеток; 

Программа, которая использует описанный класс, должна иметь консольный интерфейс с меню для игры в "Кубик Рубика".

\subsection{Натуральная дробь со знаком}

Описать класс, реализующий тип данных "Натуральная дробь со
знаком". Натуральная дробь всегда должна хранится в сокращенном виде.
Класс должен реализовывать следующие возможности:

получение определителя, знаменателя и целой части;
сложение двух натуральных дробей и натуральной дроби с целым (оператор +);
сложение двух натуральных дробей и натуральной дроби с целым с присваиванием (оператор +=);
вычитание двух натуральных дробей и натуральной дроби с целым (оператор -);
вычитание двух натуральных дробей и натуральной дроби с целым с присваиванием (оператор -=);
произведение двух натуральных дробей и натуральной дроби с целым с числом (оператор *);
произведение двух натуральных дробей и натуральной дроби с целым с присваиванием (оператор *=);
деление двух натуральных дробей и натуральной дроби с целым (оператор /);
деление двух натуральных дробей и натуральной дроби с целым с присваиванием (оператор /=);
операторы пре- и постинкремента, пре- и постдекремента (++, --);
операторы для сравнения двух натуральных дробей и натуральной дроби с целым (операторы >, >=, <, <=);
приведение к double; 

Вариант 10 "Многочлен от одной переменной"

Описать класс многочлена от одной переменной, задаваемых степенью многочлена и массивом коэффициентов. Класс должен реализовывать следующие возможности:

получение значений коэффициентов (оператор []);
вычисление значения многочлена для заданного аргумента (оператор ());
сложение двух многочленов (оператор +);
сложение двух многочленов с присваиванием (оператор +=);
вычитание двух многочленов (оператор -);
вычитание двух многочленов с присваиванием (оператор -=);
произведение двух многочленов (оператор *);
произведение двух многочленов с присваиванием (оператор *=);
деление двух многочленов (оператор /);
деление двух многочленов с присваиванием (оператор /=); 



Тема

Изучение основ объектно-ориентированного программирования с использованием языка С++.
Цель

Получить начальные навыки объектно-ориентированного программирования с использованием языка С++.
Содержание

Классы и перегрузка операторов в C++:
понятие класса и объекта;
поля и методы класса класса;
статические методы класса;
определение методов внутри и вне класса;
принцип инкапсуляции;
управление доступом (области видимости);
конструктор и деструктор;
this;
ссылка на объект;
использование спецификаторы const в возвращаемом типе, в типе аргументов и после метода класса;
конструктор по умолчанию;
конструктор копирования;
спецификатор mutable для поля класса;
динамическое выделение памяти под объекты (операторы new и delete);
ссылка на себя;
перегрузка операторов +, -, *, /, =, ==, !=, >, >=. <, <= и т.д.;
перегрузка потоковых операторов (<<, >>);
операторы-члены и не-члены;
std::string (строки в стиле С++). 
unit-тестирование;
документирование кода:
документирование есть комментирование с использованием doxygen;
краткое и полное описание;
тэг;
тэги file, author, brief, details, param, return, see;
генерация документации. 

Задание

Реализовать на языке С++ один из нижеперечисленных вариантов;
Написать unit-тесты для реализованных классов;
должны быть сформулированы словами не менее 30 тестовых случаев для методов тестируемого класса/классов (нумерованный список в комментариях в одном из исходных файлов программы);
для каждого выделенного тестового случая написать unit-тест с использованием библиотеки UnitTest++ и проверить, чтобы он был успешным;
методические указания по TDD и unit-тестированию: \\Info\StudInfo\~Методическое обеспечение кафедры\~Учебные курсы\2 курс\ППвИС\@Лабораторный практикум\@ЛР1\TDD_UnitTest++.pdf 
Написать документацию для реализованных классов. 

Каждый из реализованных классов должен иметь следующие свойства:

конструктор копирования и оператор =, если это уместно;
деструктор, если это необходимо;
операторы для сравнения (операторы ==, !=).
операторы для работы с потоками ввода ('>>) и вывода (<<). 

Средства разработки

MS Visual Studio 2003
MS Visual Studio 2005
MS Visual Studio 2008
MS Visual Studio 2010 

Часто встречающиеся ошибки

Студенты забывают использовать ссылки C++ & для избежания копирования объектов. Например, 

void f(std::string str); // Накладные расходы на копирование объекта.

void f(const std::string & str); // Передача по ссылке без копирования. В данном случае не забываем про const, чтобы нельзя было изменить объект из функции.



Отсутствие спецификатора const в местах, где он необходим по смысле. Необходимо как можно чаще его использовать в возвращаемых типах, в типах аргументов и для задания константных методов. 

Это делает код строже, позволяет лучше специфицировать интерфейс для внешнего пользователя и избежать ошибок (компилятор будет ругаться на попытки изменить const-объект).

Отсутствие понимания разницы между оператором + и += (с присваиванием) (тоже самое и для других похожих операторов). Внимательно изучите возвращаемые типы этих операторов и разберитесь с понятием "Ссылка на себя". 

Студенты не могут ответить на вопрос "В каких случаях нужен конструктор копирования?". 

Литература
Х. Дейтел "Как программировать на С++" 5-ое издание 2008 года

Для выполнения лабораторной работы необходимо прочитать главы 3, 9, 10, 11. Ссылочный тип и спецификатор const и mutable не описаны в этих главах. Эта книга рекомендуется.
Б. Страуструп "Язык программирования С++"

Для выполнения лабораторной работы необходимо прочитать главы 5 и 6. Ссылочный тип и спецификатор const описаны в более ранних главах. Для новичка эта книга сложновата.
Х. Дейтел "Как программировать на С++" (старое издание)

Для выполнения лабораторной работы необходимо прочитать главы 6, 7, 8. Ссылочный тип и спецификатор const описаны в более ранних главах. Эта книга как раз для новичка.

При работе по этой книге могут возникнуть проблемы с запуском примеров в среде Visual Studio. Рассмотрим эту проблему на основе заголовочного файла iostream.h. Он является частью библиотеки STL (Стандартная библиотека шаблонов). По стандарту рекомендуется подключать заголовочный файл iostream, а не iostream.h. Заголовочные файлы с расширением .h включены в STL для обратной совместимости с более старыми версиями. Но STL, который идет вместе с Visual Studio, не содержит файлов обратной совместимости, поэтому необходимо использовать не такой код:

#include <iostream.h>

void main() {
// ...
cout << "Hello" << endl;
// ...
}

а вот такой код:

#include <iostream>

using namespace std;

void main() {
// ...
cout << "Hello" << endl;
// ...
}

С. Макконнелл "Совершенный код"

В этой книге необходимо прочитать главу 22, которая связана с тестированием ПО, которая проводится разработчиком.
Варианты задания



Вариант 11 "Длинное целое со знаком"

Описать класс, реализующий тип данных "длинное целое со знаком" и работу с ними. Длинна целого числа должна быть неограниченной. Класс должен реализовывать следующие возможности:

оператор преобразования длинного целого к целому;
сложение двух длинных целых и длинного целого с целым (оператор +);
сложение двух длинных целых и длинного целого с целым с присваиванием (оператор +=);
вычитание двух длинных целых и длинного целого с целым (оператор -);
вычитание двух длинных целых и длинного целого с целым с присваиванием (оператор -=);
произведение двух длинных целых и длинного целого с целым (оператор *);
произведение двух длинных целых и длинного целого с целым с присваиванием (оператор *=);
деление двух длинных целых и длинного целого на целое (оператор /);
деление двух длинных целых и длинного целого на целое с присваиванием (оператор /=);
операторы пре- и постинкремента, пре- и постдекремента (++, --);
операторы для сравнения двух длинных целых и длинного целого с целым (операторы >, >=, <, <=); 

Теория матриц

Описать класс, реализующий тип данных "Вещественная матрица".
Класс должен реализовывать следующие возможности:

матрица произвольного размера с динамическим выделением памяти;
операторы пре- и постинкремента, пре- и постдекремента (++, --); 

Вариант 12 "Вещественная матрица"

Класс должен реализовывать следующие дополнительные возможности:

изменение числа строк и числа столбцов;
загрузка матрицы из файла;
извлечение подматрицы заданного размера;
проверка типа матрицы (квадратная, диагональная, нулевая, единичная, симметрическая, верхняя треугольная, нижняя треугольная);
транспонированние матрицы; 

Вариант 13 "Вещественная матрица (усложненный)"

Класс должен реализовывать следующие дополнительные возможности:

сложение двух матриц и матрицы с числом (оператор +);
сложение двух матриц и матрицы с числом с присваиванием (оператор +=);
вычитание двух матриц и матрицы с числом (оператор -);
вычитание двух матриц и матрицы с числом с присваиванием (оператор -=);
произведение двух матриц и матрицы с числом (оператор *);
произведение двух матриц и матрицы с числом с присваиванием (оператор *=);
деление двух матриц и матрицы на числом (оператор /);
деление двух матриц и матрицы на числом с присваиванием (оператор /=);
возведение матрицы в степень (оператор ^);
возведение матрицы в степень с присваиванием (оператор ^=);
вычисление детерминанта;
вычисление нормы; 

Абстрактные машины

Описать классы, реализующие абстрактную машину, ее ленту, программу и правила, каретку, алфавит, строку. Набор классов зависит от вида абстрактной машины. Количество классов может варьироваться, но минимально должно быть три класса.
Классы должны реализовывать следующие возможности:

загрузка программы из потока ввода;
загрузка состояние ленты из потока;
добавления/удаления/просмотр правил;
задания/изменения значений на ленте;
осуществление шага и интерпретации всей программы (можно при помощи опрераторов инкремента и декремента); 

Написать программу, которая принимает в качестве аргумента командной строки путь к файлу, который содержит начальное абстрактной машины и программу для интепретации. После запуска программа считывает содержимое этого файла и осуществляет интерпретацию правил. Если в командной строке был указан аргумент -log, тогда после выполнения каждого правила на консоль должна выводится информация о состоянии абстрактной машины.
Вариант 14 "Машина Поста"

Описать классы, реализующие машину Поста.
Вариант 15 "Машина Тьюринга"

Описать классы, реализующие машину Тьюринга.
Вариант 16 "Нормальные алгорифмы Маркова"


\end{document}


